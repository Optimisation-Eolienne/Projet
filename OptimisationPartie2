import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import plotly.graph_objects as go
from cylp.cy import CyClpSimplex
from cylp.py.modeling.CyLPModel import CyLPModel,CyLPArray


#| Paramètres

N_pays = 15
N_sites = 642
N_heures_par_annee = 24*365
N_annees = 7/365
N_heures = int(np.ceil(N_heures_par_annee*N_annees))

T = 3
m = int(np.floor(N_heures/T))
t = np.linspace(0,N_heures,m)/N_heures_par_annee
eta_turbinage = 0.75
cout_instal_onshore  = 168903
cout_instal_offshore = 300336
cout_amorti_gaz = 94956
cout_fonct_gaz  = 65

index_pays = -1
stockage_hydro = CyLPArray([0.3*1e6 , 3.2*1e6 , 0.01*1e6 , 0 , 18.4*1e6 , 9.8*1e6 , 0.24*1e6 , 7.9*1e6 , 0.005*1e6 , 84.147*1e6 , 0 , 2.6*1e6 , 1.2*1e6 , 33.756*1e6 , 8.4*1e6])
p_turbinage = np.array([8587 , 12009 , 1417 , 9 , 18372 , 25132 , 527 , 21117 , 1140 , 28941 , 37 , 5052 , 4269 , 16637 , 15101])
p_pompage = np.array([5223 , 3580 , 1307 , 0 , 5347 , 4303 , 292 , 7544 , 1100 , 1396 , 0 , 1029 , 2744 , 45 , 1636 ])
liste_pays = ['Allemagne','Autriche','Belgique','Danemark','Espagne','France','Irlande','Italie','Luxembourg',\
             'Norvège','Pays-Bas','Portugal','Royaume-Uni','Suède','Suisse']

#| Chargement des données

consommations = np.genfromtxt('Consommations.csv', delimiter=',')[:,:N_heures]
sites = pd.read_csv("Sites.csv",index_col="index site").sort_index()
rendements_offshore = np.genfromtxt('Rendements_offshore.csv', delimiter=',')[:,:N_heures]
rendements_onshore = np.genfromtxt('Rendements_onshore.csv', delimiter=',')[:,:N_heures]
apports_hydro = np.genfromtxt('Apports-hydro.csv', delimiter=',')[:,:N_heures]


#| Matrice et vecteurs principaux utilisés dans les problèmes

P_max = CyLPArray(sites["capacites"])

is_offshore = pd.Series(0,index=range(N_sites))
is_offshore[sites["capacite offshore"]=="Oui"] = 1
is_offshore = CyLPArray(is_offshore)

apport_hydro_total = np.zeros((N_pays,m))
for j in range(N_pays):
    total = 0
    for i in range(m):
        total += np.sum(apports_hydro[j,i*T:(i+1)*T]) 
        apport_hydro_total[j,i] = total

consommation_par_periode = np.zeros((N_pays,m))
for i in range(m):
    for j in range(N_pays):
        consommation_par_periode[j,i] = np.sum(consommations[j,i*T:(i+1)*T])

A = np.matrix(np.zeros((m,N_sites)))
for i in range(m):
    for j in range(N_sites):
        if is_offshore[j]==1:
            A[i,j] = np.sum(rendements_offshore[j,i*T:(i+1)*T])
        else:
            A[i,j] = np.sum(rendements_onshore[j,i*T:(i+1)*T])

c = (cout_instal_offshore*is_offshore+cout_instal_onshore*(1-is_offshore))*N_annees

U = np.matrix(np.tril(np.ones((m,m))))

if index_pays==-1:
    S_max = np.sum(stockage_hydro)
    h1 = np.sum(p_pompage)*T
    h2 = 1/eta_turbinage*np.sum(p_turbinage)*T
    R = CyLPArray(np.zeros(m))
    E = CyLPArray(np.zeros(m))
    for i in range(m):
        R[i] = np.sum(apport_hydro_total[:,i])
        E[i] = np.sum(consommation_par_periode[:,i])
else:
    S_max = stockage_hydro[index_pays]
    h1 = p_pompage[index_pays]*T
    h2 = 1/eta_turbinage*p_turbinage[index_pays]*T
    R = CyLPArray(np.transpose(apport_hydro_total[index_pays,:]))
    E = CyLPArray(consommation_par_periode[index_pays,:])


#| Modèle d'optimisation

def model_1(theta=0.5):        
    
    S_0 = theta*S_max
    
    simplex = CyClpSimplex()
    
    #Variables
    P = simplex.addVariable('P',N_sites)
    q1 = simplex.addVariable('q1',m) # eoliennes->barrage
    q2 = simplex.addVariable('q2',m) # barrage->production
    q3 = simplex.addVariable('q3',m) # eoliennes->production
    
    #Contraintes
    simplex.addConstraint(0 <= P <= P_max,"Bornes sur les puissances installées")
    simplex.addConstraint(0 <= q1 <= h1,"Bornes sur le transfert Eolienne->Barrage")
    simplex.addConstraint(0 <= q2 <= h2,"Bornes sur le transfert Barrage->Production")
    simplex.addConstraint(0 <= q3)
    simplex.addConstraint(q3 + eta_turbinage*q2 >= E,"Demande d'énergie satisfaite")
    simplex.addConstraint(q1 + q3 - A*P == 0,"Conservation de l'énergie produite par les éoliennes")
    simplex.addConstraint(- S_0 - R <= U*(q1 - q2),"Capacité du barrage positive")
    simplex.addConstraint(U*(q1 - q2) <= S_max - S_0 - R,"Capacité maximale du barrage")
    simplex.addConstraint(q2.sum() - q1.sum() == R[-1],"Stockage initial et final identique")
    
    #Objectif
    simplex.objective = c*P
    
    simplex.primal()
    print(simplex.getStatusString())
    
    return simplex.primalVariableSolution['P'],simplex.objectiveValue,simplex,theta

def model_2(theta=0.5):
        
    S_0 = theta*S_max
    d = 1/2*c*P_max
    B = 1/2*P_max*A
    
    model = CyLPModel()
    
    #Variables
    x = model.addVariable('x',N_sites,isInt=True) 
    q1 = model.addVariable('q1',m) # eoliennes->barrage
    q2 = model.addVariable('q2',m) # barrage->production
    q3 = model.addVariable('q3',m) # eoliennes->production
      
    #Contraintes
    model.addConstraint(0 <= x <= 2,"Bornes sur la proportion de puissance installée")
    model.addConstraint(0 <= q1 <= h1,"Bornes sur le transfert Eolienne->Barrage")
    model.addConstraint(0 <= q2 <= h2,"Bornes sur le transfert Barrage->Production")
    model.addConstraint(0 <= q3)
    model.addConstraint(q1 + q3 - B*x == 0,"Conservation de l'énergie produite par les éoliennes")
    model.addConstraint(q3 + eta_turbinage*q2 >= E,"Demande d'énergie satisfaite")
    model.addConstraint(- S_0 - R <= U*(q1 - q2),"Capacité minimale du barrage")
    model.addConstraint(U*(q1 - q2) <= S_max - S_0 - r,"Capacité maximale du barrage")
    model.addConstraint(q2.sum() - q1.sum() == r[-1],"Stockage initial et final identique")
    
    #Objectif
    model.objective = d*x
    
    simplex = CyClpSimplex(model)
    cbcModel = simplex.getCbcModel()
    cbcModel.branchAndBound()
    print(simplex.getStatusString())
    
    return cbcModel.primalVariableSolution['x'],cbcModel.objectiveValue,cbcModel,theta

def model_3(theta=0.5):        
    
    S_0 = theta*S_max
    
    s = cout_amorti_gaz*N_annees
    V = eta_turbinage*np.matrix(np.diag(np.ones(m)))
    
    simplex = CyClpSimplex()
    
    #Variables
    P = simplex.addVariable('P',N_sites)
    G = simplex.addVariable('G',1)
    U = simplex.addVariable('U',m)
    q1 = simplex.addVariable('q1',m) # eoliennes->barrage
    q2 = simplex.addVariable('q2',m) # barrage->production
    q3 = simplex.addVariable('q3',m) # eoliennes->production
    q4 = simplex.addVariable('q4',m) # usine->barrage
    q5 = simplex.addVariable('q5',m) # usine->production
    
    #Contraintes
    simplex.addConstraint(0 <= P <= P_max,"Bornes sur les puissances installées")
    simplex.addConstraint(0 <= q1 <= h1,"Bornes sur le transfert Eolienne->Barrage")
    simplex.addConstraint(0 <= q2 <= h2,"Bornes sur le transfert Barrage->Production")
    simplex.addConstraint(0 <= q3)
    simplex.addConstraint(0 <= q4)
    simplex.addConstraint(0 <= q5)
    
    for i in range(m):
        simplex.addConstraint(U[i] - G <= 0)
    simplex.addConstraint(0 <= U)
    
    simplex.addConstraint(- S_0 - R <= U*(q1 + q4 - q2),"Capacité du barrage positive")
    simplex.addConstraint(U*(q1 + q4 - q2) <= S_max - S_0 - R,"Capacité maximale du barrage")
    simplex.addConstraint(q1 + q3 - A*P == 0,"Conservation de l'énergie produite par les éoliennes")
    simplex.addConstraint(q4 + q5 - U == 0)
    simplex.addConstraint(q3 + q5 + eta_turbinage*q2 >= E,"Demande d'énergie satisfaite")
    simplex.addConstraint(q2.sum() - q1.sum() - q4.sum() == R[-1],"Stockage initial et final identique")
    
    #Objectif
    simplex.objective = c*P + s*G + cout_fonct_gaz*U.sum()
    
    simplex.primal()
    print(simplex.getStatusString())
    
    return simplex.primalVariableSolution['U'],simplex.objectiveValue,simplex,theta

def plotModel_Consommation(result,model=1):
    s = result[2]
    if model==1:
        E_prod = eta_turbinage*s.primalVariableSolution['q2']+s.primalVariableSolution['q3']
    if model==3:
        E_prod = eta_turbinage*s.primalVariableSolution['q2']+s.primalVariableSolution['q3']+s.primalVariableSolution['q5']
    
    E_prod_tot = np.sum(E_prod)
    E_tot =  np.sum(E)
    
    fig = plt.figure(figsize=(16,3))
    g = fig.add_subplot(1,1,1)
    g.set_title("Graphique de l'énergie produite et consommée en fonction du temps")
    g.set_ylabel("Energie [TWh]")
    g.set_xlabel("Temps [année]")
    g.plot(t,E_prod*10**(-6),label="Energie produite")
    g.plot(t,E*10**(-6),label="Energie consommée")
    
    plt.legend()
    plt.show()
    
    print("Energie totale produite : {:.0f} [MWh]".format(E_prod_tot))
    print("Proportion de l'énergie produite qui n'a pas été consomée : {:.2f}%".format(100*(E_prod_tot-E_tot)/E_prod_tot))
    
    
def plotModel_Energie(result,model=1):
    pass
    
def plotModel_Barrage(result,model=1):
    s = result[2]
    E_eolienne_stock = np.zeros(m)
    total = 0
    for i in range(m):
        total += s.primalVariableSolution['q1'][i]
        E_eolienne_stock[i] = total
    if model==1:
        S = (U@s.primalVariableSolution['q1'] - U@s.primalVariableSolution['q2'] + R).T
    S += result[3]*S_max
    
    fig = plt.figure(figsize=(16,6))
    plt.subplots_adjust(hspace=0.5)
    g1 = fig.add_subplot(2,1,1)
    g2 = fig.add_subplot(2,1,2)
    
    g1.set_title("Graphique représentant l'énergie stockée dans le barrage en fonction du temps")
    g1.set_ylabel("Energie [TWh]")
    g1.set_xlabel("Temps [année]")
    g1.plot(t,S*10**(-6))
    
    g2.set_title("Graphique de l'évolution du stockage cumulé des différentes énergies en fonction du temps")
    g2.set_ylabel("Energie [TWh]")
    g2.set_xlabel("Temps [année]")
    g2.plot(t,E_eolienne_stock*10**(-6),label="Energie éolienne stockée")
    g2.plot(t,R*10**(-6),label="Energie stockée provennant des cours d'eau")
    
    plt.legend()
    plt.show()
    
def plotModel_Time():
    pass

def model_1b(index_pays, theta=0.5):  
    pays = liste_pays[index_pays]
    
    #Adaptation de P_max      
    dans_le_pays = pd.Series(0,index=range(N_sites))
    dans_le_pays[sites["pays"]==pays] = 1
    dans_le_pays = CyLPArray(dans_le_pays)
    P_max_loc = []
    for i in range(N_sites):
        if(dans_le_pays[i]):
            P_max_loc.append(P_max[i])
    P_max_loc = CyLPArray(P_max_loc)
    N_sites_loc = dans_le_pays.sum()
    
    #Adaptation de la matrice des rendements
    new_A = np.matrix(np.zeros((m,N_sites_loc)))
    col = 0
    for i in range(N_sites):
        if(dans_le_pays[i]):
            new_A[:,col] = A[:,i]
            col += 1
    
    #Adaptation des couts
    new_cout = []
    for i in range(N_sites):
        if(dans_le_pays[i]):
            new_cout.append(c[i])
    new_cout = CyLPArray(new_cout)
    
    #VAriable adapté au pays
    S_max = stockage_hydro[index_pays]
    h1 = p_pompage[index_pays]*T
    h2 = 1/eta_turbinage*p_turbinage[index_pays]*T
    R = CyLPArray(np.transpose(apport_hydro_total[index_pays,:]))
    E = CyLPArray(consommation_par_periode[index_pays,:])
    
    #Barage au début
    S_0 = theta*S_max
    
    simplex = CyClpSimplex()
    
    #Variables
    P = simplex.addVariable('P',N_sites_loc)   #TODO
    q1 = simplex.addVariable('q1',m) # eoliennes->barrage
    q2 = simplex.addVariable('q2',m) # barrage->production
    q3 = simplex.addVariable('q3',m) # eoliennes->production
    
    #Contraintes
    simplex.addConstraint(0 <= P <= P_max_loc,"Bornes sur les puissances installées")
    simplex.addConstraint(0 <= q1 <= h1,"Bornes sur le transfert Eolienne->Barrage")
    simplex.addConstraint(0 <= q2 <= h2,"Bornes sur le transfert Barrage->Production")
    simplex.addConstraint(0 <= q3)
    simplex.addConstraint(q3 + eta_turbinage*q2 >= E,"Demande d'énergie satisfaite")
    simplex.addConstraint(q1 + q3 - new_A*P == 0,"Conservation de l'énergie produite par les éoliennes")
    simplex.addConstraint(- S_0 - R <= U*(q1 - q2),"Capacité du barrage positive")
    simplex.addConstraint(U*(q1 - q2) <= S_max - S_0 - R,"Capacité maximale du barrage")
    simplex.addConstraint(q2.sum() - q1.sum() == R[-1],"Stockage initial et final identique")
    
    #Objectif
    simplex.objective = new_cout*P
    
    simplex.primal()
    print(simplex.getStatusString())
    
    return simplex.primalVariableSolution['P'],simplex.objectiveValue,simplex,theta


def main():
    res = model_1b(0)
    plotModel_Consommation(res,model=1)
    plotModel_Barrage(res,model=1)
    print(res[1])
    
main()
